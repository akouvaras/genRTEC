%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Prompt RTEC-1:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
You are an assistant in constructing rules in the language of the Run-Time Event Calculus (RTEC), given a composite activity description in natural language. The Event Calculus is a logic-based formalism for representing and reasoning about events and their effects. The Run-Time Event Calculus (RTEC) is a Prolog programming implementation of the Event Calculus, that has been optimised for composite activity recognition. Below, we summarise the language of RTEC. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Prompt RTEC-2:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Following the Prolog convention, variables start with an upper-case letter, while predicates and constants start with a lower-case letter. Each rule ends with a full-stop “.”, while the head of a rule is separated from its body with “:-”. 

A fluent is a property that may have different values at different points in time. The term F=V denotes that fluent F has value V.  Boolean fluents are a special case in which the possible values are “true” and “false”. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Prompt RTEC-3:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Below are the predicates of RTEC.

RTEC - Predicate 1: happensAt(E,T)
Meaning: Event “E” occurs at time “T”.

RTEC - Predicate 2: initially(F=V)
Meaning: The value of fluent “F” is “V” at time “0”.

RTEC - Predicate 3: holdsAt(F=V,T)
Meaning: The value of fluent “F” is “V” at time “T”.

RTEC - Predicate 4: holdsFor(F=V,I)
Meaning: “I” is the list of the maximal intervals during which “F=V” holds continuously.

RTEC - Predicate 5: initiatedAt(F=V,T)
Meaning: At time “T”, a period of time for which “F=V” is initiated.

RTEC - Predicate 6: terminatedAt(F=V,T)
Meaning: At time “T”, a period of time for which F=V is terminated.

RTEC - Predicate 7: union_all(L,I)
Meaning: “I” is the list of maximal intervals produced by the union of the lists of maximal intervals of list “L”.

RTEC - Predicate 8: intersect_all(L,I)
Meaning: “I” is the list of maximal intervals produced by the intersection of the lists of maximal intervals of list “L”.

RTEC - Predicate 9: relative_complement_all(I',L,I)
Meaning: “I” is the list of maximal intervals produced by the relative complement of the list of maximal intervals I' with respect to every list of maximal intervals of list “L”.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Prompt RTEC-4:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
RTEC also includes two built-in events.

Built-in event 1: start(F=V)
Meaning: Event “start(F=V)” takes place at the starting point of each maximal interval of fluent-value pair “F=V”.

Built-in event 2: end(F=V)
Meaning: Event “end(F=V)” takes place at the ending point of each maximal interval of fluent-value pair “F=V”.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Prompt RTEC-SF1:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
There are two ways in which a composite activity may be defined in the language of RTEC. In the first case, a composite activity definition may be specified by means of rules with “initiatedAt(F=V, T)” or “terminatedAt(F=V, T)” in their head. This is called a simple fluent definition.

The first body literal of an “initiatedAt(F=V,T)” rule is a positive “happensAt” predicate; this predicate is followed by a possibly empty set of positive or negative “happensAt” and “holdsAt” predicates. Negative predicates are prefixed with “not” which expresses negation-by-failure. In some cases, the body of an “initiatedAt(F=V,T)” rule may include predicates expressing background knowledge. 

“terminatedAt(F=V,T)” rules are specified in a similar way. 

Below, you may find two examples of composite activity definitions, from the maritime domain, expressed as simple fluents. 

Example 1: Given the description below, provide the rules in the language of RTEC.
 
Description - “withinArea”: We aim to identify the maximal intervals during which a vessel is within an area of interest. Α vessel is considered to start being within an area of interest when it enters the area. On the other hand, the vessel is considered to stop being within an area of interest when (1) it leaves the area that it had entered, or (2) when a communication gap starts. 

Answer:  The activity “withinArea” is expressed as a Boolean simple fluent with two arguments, i.e., “Vessel” and “AreaType”. This activity starts when a vessel enters an area of interest. We use an "initiatedAt" rule to express this initiation condition. The body literals of this rule are an event labelled “entersArea” with two arguments, “Vessel” and “Area”, and a background knowledge predicate named “areaType” with two arguments, “Area” and “AreaType”. Below, you may find this rule in the language of RTEC:  

initiatedAt(withinArea(Vessel, AreaType)=true, T) :-
    happensAt(entersArea(Vessel, Area), T),
    areaType(Area, AreaType).

The activity “withinArea” ends when a vessel leaves the area that it had entered. We use a “terminatedAt” rule to describe this termination condition. This rule includes an event named “leavesArea” with two arguments, i.e. “Vessel” and “Area”, and the background knowledge predicate “areaType”. Below, you may find this rule in the language of RTEC: 

terminatedAt(withinArea(Vessel, AreaType)=true, T) :-
    happensAt(leavesArea(Vessel, Area), T),
    areaType(Area, AreaType).

The activity “withinArea” also ends when the vessel stops transmitting its position, i.e. when a communication gap starts. We use a “terminatedAt” rule to express this termination condition. In this rule, the second argument of the “withinArea” fluent is a ‘free’ Prolog variable, i.e. a variable starting with ‘_’. The body of this rule includes a single event named “gap_start” with one argument, i.e. “Vessel”. Below, you may find this rule in the language of RTEC: 

terminatedAt(withinArea(Vessel, _AreaType)=true, T) :-
    happensAt(gap_start(Vessel), T).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Prompt RTEC-SF2:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Example 2: Given the description below, provide the rules in the language of RTEC.
 
Description -  “stopped”: We aim to identify the maximal intervals during which a vessel is stopped. A vessel is considered to start being stopped when it becomes idle (1) near some port, or (2) far from all ports. The vessel is no longer considered to be stopped when (1) it stops being idle, or (2) when a communication gap starts. 

Answer: The activity “stopped” is expressed as a simple fluent. This activity starts when a vessel becomes idle near some port. We use an “initiatedAt” rule to describe this initiation condition. The output is the fluent “stopped”, which has one argument, i.e. “Vessel”, and value “nearPorts”. The “initiatedAt” rule includes an event named “stop_start” with one argument, i.e. “Vessel”. We verify that the vessel is currently near some port by requiring that the fluent-value pair “withinArea(Vessel, nearPorts)=true” must hold. This condition refers to the activity “withinArea”, which was learned in a previous example. Below, you may find this rule in the language of RTEC: 

initiatedAt(stopped(Vessel)=nearPorts, T) :-
    happensAt(stop_start(Vessel), T),
    holdsAt(withinArea(Vessel, nearPorts)=true, T).

The activity “stopped” may also start when a vessel becomes idle far from all ports. In this case, the “stopped” fluent has value “farFromPorts”. We use an “initiatedAt” rule to express this initiation condition. The body of this rule includes an event named “stop_start” with one argument, i.e. “Vessel”. We verify that the vessel is currently far from all ports by requiring that the fluent-value pair “withinArea(Vessel, nearPorts)=true” does not hold. Below, you may find this rule in the language of RTEC: 

initiatedAt(stopped(Vessel)=farFromPorts, T) :-
    happensAt(stop_start(Vessel), T),
    not holdsAt(withinArea(Vessel, nearPorts)=true, T).

The activity “stopped” ends when a vessel stops being idle, irrespective of the location of the vessel. We use a “terminatedAt” rule to express this termination condition. Moreover, we use a free Prolog variable to express the value of the “stopped” fluent, called “_Status”, i.e. we place no constraints on the value of the “stopped” fluent. The “terminatedAt” rule includes a single event named “stop_end” with one argument, i.e. “Vessel”. Below, you may find this rule in the language of RTEC: 

terminatedAt(stopped(Vessel)=_Status, T) :-
    happensAt(stop_end(Vessel), T).

The activity “stopped” may also end when a communication gap starts. We use a “terminatedAt” rule to express this termination condition. This rule includes the built-in “start” event of RTEC, which expresses the start times of the maximal intervals of a given fluent-value pair. In this case, the “start” event is applied to the gap fluent, expressing the times at which a communication gap for the vessel in question starts. Below, you may find this rule in the language of RTEC: 

terminatedAt(stopped(Vessel)=_Status, T) :-
    happensAt(start(gap(Vessel)=_GapStatus), T).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Prompt RTEC-SDF1:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The second way in which a composite activity may be defined in the language of RTEC concerns statically determined fluents. In this case, a composite activity definition may be specified by means of a rule with “holdsFor(F=V, I)” in its head. The body of such a rule may include “holdsFor” conditions for fluents other than F, as well as some of the interval manipulation constructs of RTEC, i.e. “union_all”, “intersect_all”, and “relative_complement_all”. In some cases, a “holdsFor(F=V, I)” rule may include predicates expressing background knowledge. A rule with “holdsFor(F=V, I)” in the head is called a statically determined fluent definition. Below you may find two examples of composite maritime activities expressed as statically determined fluents. 

Example 1: Given the description below, provide the rules in the language of RTEC.
 
Description -  “underWay”: We aim to identify the maximal intervals during which a vessel is underway. A vessel is considered underway as long as it is not stopped, i.e., it has a speed below, normal, or above the expected typical speed limits for its type.  

Answer: The activity “underWay” is expressed as a statically determined fluent. Rules with “holdsFor” in the head specify the conditions in which a fluent holds. We use a “holdsFor” rule to describe that the “underWay” activity lasts as long as a vessel is not stopped. The output is Βoolean fluent named “underWay” with one argument, i.e. “Vessel”. We specify “underWay” with the use of the fluent “movingSpeed”. We express “underWay” as the disjunction of the three values of “movingSpeed”, i.e. “below”, “normal” and “above”. Disjunction in “holdsFor” rules is expressed by means of “union_all”. Below, you may find this rule in the language of RTEC: 

holdsFor(underWay(Vessel)=true, I) :-
	holdsFor(movingSpeed(Vessel)=below, I1),
	holdsFor(movingSpeed(Vessel)=normal, I2),
	holdsFor(movingSpeed(Vessel)=above, I3),
	union_all([I1,I2,I3], I).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Prompt RTEC-SDF2:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Example 2: Given the description below, provide the rules in the language of RTEC.

Description -  “rendezVous”: A vessel may engage in illegal activities such as illegal cargo transfers, commonly referred to as vessel rendez-vous. This activity is considered to occur as long as two vessels are close to each other, both are moving at low speed, and they are far from the coastline. Furthermore, neither of the two vessels should be a tug boat or a pilot vessel. We are interested in vessel meetings with a duration that exceeds the expected minimum time required for a suspicious action, like an illegal cargo transfer.

Answer: The activity “rendezVous” is expressed as a statically determined fluent. We use a “holdsFor” rule to describe that the “rendezVous” activity lasts as long as two vessels are sailing at a low speed or are stopped far from all ports, while neither of them is close to a port or a coastline, and neither of them is a tug boat or a pilot vessel,. The output is a Boolean fluent named “rendezVous” with two arguments, i.e. “Vessel1” and “Vessel2”. To express that the two vessels must be close to each other, we use a Boolean fluent named “proximity” with two arguments, i.e. “Vessel1” and “Vessel2”. To express that neither of the vessels is a tug boat or a pilot vessel, we use a background knowledge predicate named “oneIsTug” with two arguments, i.e. “Vessel1” and “Vessel2”, and a background knowledge predicate named “oneIsPilot” with two arguments, i.e. “Vessel1” and “Vessel2”, and require that these predicates do not hold using “not”. To express that “Vessel1” has a low speed or it is stopped far from all ports, we use the interval manipulation construct “union_all”. Similarly, we employ “union_all” to express that “Vessel2” has a low speed or it is stopped far from all ports. Next, we use the interval manipulation construct “intersect_all” to express the conjunction of these two activities, i.e., that both vessels need to have a low speed or be stopped far from all ports. Subsequently, we need to express that neither of the two vessels is near a port or a coastline at this time. To do this, we employ the interval manipulation construct “relative_complement_all”, in order to exclude the situations where “Vessel1” is near a port, “Vessel1” is near a coastline, “Vessel2” is near a port or “Vessel2” is near a coastline. Finally, we need to express that the duration of the activity is greater than the minimum expected duration of a rendez-vous among vessels. To do this, we use the background knowledge predicate “thresholds” to retrieve this minimum duration from background knowledge and store it in the variable “RendezvousTime”. Then, we use the background knowledge predicate “intDurGreater” in order to filter the intervals that have been computed so far, maintaining only the ones whose duration exceeds “RendezvousTime”. Below, you may find this rule in the language of  RTEC: 

holdsFor(rendezVous(Vessel1, Vessel2)=true, I) :-
    holdsFor(proximity(Vessel1, Vessel2)=true, Ip),
    not oneIsTug(Vessel1, Vessel2),
    not oneIsPilot(Vessel1, Vessel2),
    holdsFor(lowSpeed(Vessel1)=true, Il1),
    holdsFor(lowSpeed(Vessel2)=true, Il2),
    holdsFor(stopped(Vessel1)=farFromPorts, Is1),
    holdsFor(stopped(Vessel2)=farFromPorts, Is2),
    union_all([Il1, Is1], I1b),
    union_all([Il2, Is2], I2b),
    intersect_all([I1b, I2b, Ip], If), If\=[],
    holdsFor(withinArea(Vessel1, nearPorts)=true, Iw1),
    holdsFor(withinArea(Vessel2, nearPorts)=true, Iw2),
    holdsFor(withinArea(Vessel1, nearCoast)=true, Iw3),
    holdsFor(withinArea(Vessel2, nearCoast)=true, Iw4),
    relative_complement_all(If,[Iw1, Iw2, Iw3, Iw4], Ii),
    thresholds(rendezvousTime, RendezvousTime),
    intDurGreater(Ii, RendezvousTime, I).
